# 回答用紙 

(本Markdownファイルを記入し、課題を完成、提出する)

###  プログラミングII　2025　課題レポート（第1回）
###  提出期限：　2024/10/17(金) 17:00

-------

レポート提出者：

|クラス|学籍番号|　氏名　|
|  B  |20125047|星野日那|



-----

##  問題１ リスト、タプル、計算式　【通常問題、回答必須】

|空欄|適切なコードに書き換えてください|
|-|-|
|(1)|``` (a+b/c)*d  ```|
|(2)|```(b*c+d)/a  ```|
|(3)|```   a/(b/(c+d)) ```|
|(4)|``` (a*b+c)/d   ```|
|(5)|``` d/(a-b/c)   ```|

###  問題1 (1)  
    1,1,9,9 を使って10をつくる

```python
try:
   a,b,c,d = [1,1,9,9]
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = int(  10/0   )  #  10/0は間違い　→　10を作る計算式に書き換えて
   ten =  ('空欄A') 
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
   raise e
```

    ゼロで割ったら無限大, so let's try it again
    division by zero

    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    <ipython-input-9-eb664ac7535b> in <cell line: 1>()
         11    print(f"ゼロで割ったら無限大, so let's try it again");
         12    print(e);
    ---> 13    raise e
    

    <ipython-input-9-eb664ac7535b> in <cell line: 1>()
          2    a,b,c,d = [1,1,9,9]
          3    # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
    ----> 4    ten = int(  10/0   )  #  10/0は間違い　→　10を作る計算式に書き換えて
          5    assert ten == 10, f"Ten is {ten}, not 10"
          6    print(f"Ten is {ten}, {ten} == 10.")


    ZeroDivisionError: division by zero


###  問題1 (2)  
    3, 4, 6, 6 を使って10をつくる

```python
try:
   a,b,c,d = (3, 4, 6, 6,)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten =  ('空欄B') 
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (3)  
    4,6,6,9 を使って10をつくる



```python
try:
   a,b,c,d = (4, 6, 6, 9)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten =  ('空欄C')
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.
　

###  問題1 (4)  
    9,9,9,9 を使って10をつくる


```python
try:
   a,b,c,d = (9, 9, 9, 9)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = int(  ('空欄D')   ) 

   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (5)  
    1, 1, 5, 8 を使って10をつくる

```python
try:
   a,b,c,d = (1, 1, 5, 8)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = int(  ('空欄E')   ) 
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


##　問題１の理解度確認のための説明文

問題１で使った技法（お宝アイテム）について、**自分の言葉で**,価値や利益を説明してください：

- タプルはどういう役割で使いましたか？
- リストはどういう役割で使いましたか？
- try: except: 例外処理は何のために使いましたか？
- assertは何の役割で使いましたか？
- ten = int()のint()は、何の役割で使いましたか？

|データ構造、制御|役割、価値|
|-|-|
|タプル|**複数の値をまとめて扱う**|
|リスト|**複数の値を順番にまとめて管理したいときに使う**|
|例外処理|**エラーが出たときにプログラムが止まらないようにするときに使う**|
|assert|**条件が正しいかチェックするときに使う**|
|int()|**値を整数にするときに使う**|



----------
----------

## 問題２： 内包表現　【通常問題、回答必須】

#### 問題2-1

下記問題の4つの空欄A,B,C,Dに、適切な計算式をPythonコードで記述する

|空欄|適切なコードに書き換えてください|
|-|-|
|(1)|```  [x **3 for x in range(10)] ```|
|(2)|```  (x for x in range(10, 21)if x % 2 != 0)  ```|
|(3)|```  '{char:ord for char in string }'  ```|
|(4)|```  '{x for x in numbers if x < 0}'  ```|

-----

リスト、タプル、辞書、集合の内包表記を使って、以下のデータ構造を作成してください：

1. `0`から`9`までの整数の立方数を含むリスト

2. `10`から`20`までの整数のうち奇数を含むジェネレータをタプルに変換

3. 任意の文字列の各文字をキー、文字のUnicodeコードポイントを値とする辞書

4. 任意の数値のリストから、負の数のみを含む集合


```python
# 1. 立方数リスト
cubes = [ '空欄A' ]
```


```python
# 2. 奇数のジェネレータからタプル
odd_numbers = tuple( '空欄B' )
```


```python
# 3. 文字列の文字をキー、Unicodeコードポイントを値とする辞書
string = "Hello World."
char_to_unicode = { '空欄C' }
```


```python
# 4. 負の数のみの集合
numbers = [3, -1, -5, 8, 0, -3, 7]
negative_set = { '空欄D' }
```

----------
----------

## 問題３： Class、メソッド、インスタンス

#### 問題3-1:  ロジックの穴埋め、動作確認
- 次のコードの３つの空欄A,B,Cに、適切なコードを記述する

|空欄|適切なコードに書き換えてください|
|-|-|
|A|```  ('n//2')  ```|
|B|```  ('3*n+1')  ```|
|C|```  ('n')  ```|

- 動作確認：　期待するアウトプットを出力することを確認する

    - 期待する出力
          [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
          35
          [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
          10
          [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
          86

- 次の質問について、**自分の言葉で**　考えを説明する：

    - この例で，クラスの定義は、どこからどこまで、どのように設計されていますか？
    ```
      自分の考え・見解を記入
    ```
    - この例で，メソッドの定義は、いくつあって、どれとどれで、どのように設計されていますか？
    ```
      自分の考え・見解を記入
    ```

    - この例で，インスタンスは、どれですか？　どうやって作られて、どこに実体がありますか？
    ```
      自分の考え・見解を記入
    ```

    - インスタンスに対して、メソッドを呼び出しているのはどこですか？
    ```
      自分の考え・見解を記入
    ```


```python
### Collatzクラスとメソッドを設計・定義する

class Collatz:
  def __init__(self, n):
    self._seq = [n]

  def calc(self):
    n =  self._seq[-1]
    while n !=1:
      n = ('空欄A') if n%2==0 else ('空欄B')
      self._seq.append(n)
    return self._seq

  def __len__(self):
    return len(self._seq)

### Collatzクラスのインスタンスを作って、メソッドを使う

Ns = [237, 512, 31415]

for n in Ns:
  C = Collatz('空欄C')
  print(C.calc())
  print(len(C))

```

    [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    35
    [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
    10
    [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    86


##### 問題3-2 [Extra　Challenge]　チャレンジ問題：ジェネレータ

|空欄|適切なコードに書き換えてください|
|-|-|
|D|```  ('n')  ```|
|E|```  ('n')  ```|
|F|```  ('空欄F')  ```|

```python

class Collatz:
    def __init__(self, n):
        self.n = n

    def calc(self):
        n = self.n
        while n != 1:
            yield ('空欄D')
            n = n // 2 if n % 2 == 0 else 3 * n + 1
        yield ('空欄E')

Ns = [237, 512, 31415]
for d in Ns:
  C = Collatz(d)
  seq = [ n for n in ('空欄F') ]
  print(len(seq))
  print(seq)

```

    35
    [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    10
    [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
    86
    [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]


---
---

## 問題４

### **Stack クラスと Queue クラスの設計と実装**

#### 問題4-(1): ユースケースの比較
- スタックとキューは、さまざまなシーンで使われる有用なデータ構造です．
- 次のユースケースごとに、`Stack` と `Queue` のどちらがより適切か選択し、その理由を説明してください:

1. Web ブラウザーの戻るボタン機能：
   - `Stack`  が適切
   - なぜならば，Stackは後に入れたものを先に取り出す仕組みだから最後に開いたページから順に戻るブラウザーの動作に合っている　と考えるから

2. オフィスのプリンタのジョブ：
   - `Queue` が適切
   - なぜならば，Queueは先入れ先出しの仕組みであり先に送ったジョブを先に処理する仕組みが望ましい印刷ではQueueが適切であると考えるから

3. 括弧を含む数式の評価 (例: `((1 + 2) * 3)`)：
   - `Stack`  が適切
   - なぜならば，内側の括弧を先に計算する必要があるため後に入れたものを先に取り出すStckが適切だと考えるから
  
---
#### 問題4-(2): Pythonクラス設計

- 基本的なスタック機能とキュー機能を実装する Python クラス `Stack` とクラス `Queue` を設計して, Pythonで記述してください
   
- クラスには，少なくとも次のメソッドを含める必要があります:
- `Stack` : `push()`,`pop()`,`is_empty()`
- `Queue` : `enqueue()`,`dequeue()`,`is_empty()`

- 空の状態にも関わらず，データを取り出そうとするケース：pop()またはdequeue()などのエッジケース(例外処理)に対応してください

---
```python

class Stack:
   """
   """
   def __init__(self):
      pass  #  self._data = []
   
   def push(self,data):
      pass  #  self._data.append(data)

   def pop(self):
      pass  #  ←　コードを設計して，書き換える

   def is_empty(self):
      pass  #  ←　コードを設計して，書き換える

```

```python

class Queue:
   """
   """
   def __init__(self):
      pass  #  []
   
   def enqueue(self,data):
      pass  #  self.items.append(data)

   def dequeue(self):
      pass  #  ←　コードを設計して，書き換える

   def is_empty(self):
      pass  #  ←　コードを設計して，書き換える
    

```
---
#### 問題4-(3): 動作確認，実装のテスト (コード実行)

`Stack` クラスと `Queue` クラスを設計しコードを記述したら，次は動作確認です．
期待した動作ができているか，次の操作でコードをテストしてください:

1. **Stack**:
- スタックに 5 つの要素をプッシュします (例: `[1、2、3、4、5]`)
- スタックが空になるまで、一連のポップ操作を実行します
- is_empty()で空かどうかチェックします
- 空のスタックから再度 `pop()` を試し、例外処理を確認します

1. **Queue**:
- 5 つの要素をキューに追加します (例: `[1, 2, 3, 4, 5]`)
- キューが空になるまで、一連のデキュー操作を実行します
- is_empty()で空かどうかチェックします
- 空のキューから再度 `dequeue()` を試し、例外処理を確認します

---
#### 問題4-(4): [Extra　Challenge]　チャレンジ問題：スタックとキューによる応用

- `Queue` オブジェクトを引数として受け取り、要素を逆順にした新しいキューを返す関数 `reverse_queue(q: Queue)` を記述してください
- 実装した `Queue` クラスと `Stack` クラスのみ使用できます
- それ以外，リストや配列などの追加のデータ構造は使用できません
---

