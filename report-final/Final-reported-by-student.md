#  プログラミングII　2025　最終課題レポート回答用紙

### レポート提出者：

|クラス|学籍番号|　氏名　|
|-|-|-|
|A or B（B）| (20125047) | (星野日那) |

###  提出期限：　2026/1/30(金) 17:00  （**厳守**）

##　自作オリジナル作品のタイトル

|プログラム|オリジナル作品のタイトル名|
|-|-|
|ショート・プログラム|　(数字あてゲーム) 　|
|フリー・プログラム|　(モンスターゲーム) 　|

----
# 回答用紙 → 提出ファイルはこの様式を使うこと
- 要件を理解して、作品を作り、この回答用紙にレポート記述して提出すること
- マークダウン記法をしっかりプレビューして、記述ミスはすべて修正して完成させること


###  最終課題の概要
- これまで学修した**技法・スキルを総動員**して、
- **自由テーマ**で２つ**自分オリジナルの作品**を作成して報告すること
- (1) ショート・プログラム：　小～中規模：　練習問題級
- (2) フリー・プログラム：　　中規模：　実践問題級
- 活用した技法・手法の難易度・完成度を**技術点**として評価する
- オリジナル作品の設計思想、有用性、主張点、表現力を**芸術点**として評価する
- **オリジナル作品について、自分の言葉で丁寧に説明**する：
  - どんな目的・想いで作ったか？
  - どんなユーザニーズに応えたいと考えたか？
  - 苦労したこと・何度も失敗したこと
  - 苦労や失敗を乗り越えてたどり着いた、こだわりの設計思想・創意工夫は何か？
  
---
### 注意事項：　生成AIの活用について　（※※）

- **NG**：　**生成AIに丸投げした形跡を残すレポートは厳禁**とする：　採点対象とみなさない
- **NG**: 　** コードや説明文に生成AIの痕跡が少しでも確認されたら、減点対象**とする
   - 学生離れした、玄人のロジック、ワーディング、コードテクニックは、ソースコードをみれば一目瞭然
- **OK**:  自分の頭脳が要件定義・設計・実装・テストの主体であること
- **OK**:  部分的な質問や、自らの成果物に対して、客観的視点から助言をもらう程度で、生成AIを利用するのは許容範囲とする

---

### 技術点・芸術点の採点基準

- [x]  関数の活用
- [x] クロージャの活用
- [x] 例外処理の活用 
- [x] プロトコルの活用 
- [x] クラスの定義
- [x] インヘリタンスの定義
- [x] デコレ―タの活用
- [x] ジェネレータ、コルーチンの活用
- [x] 非同期処理の活用
- [x] 非ブロックI/Oの活用
- [x] メタクラスの定義、動的クラス生成
- [x] デザインパターンの活用
- [x] マルチスレッド並列処理
- [x] 自作パッケージ作成


# 回答編
------
# ショート・プログラム

### 作品名：


### **コード全体と、使用した技法の説明** 
   - コードを明記し、**変数・関数・クラスの役割やロジックをコメント等で簡潔に説明**する

```python
import random

correct_number = random.randint(1, 100)

max_attempts = 10

print("1から100までの数字を当ててください")
print(f"あなたには {max_attempts} 回のチャンスがあります。")

attempts = 0

is_correct = False

while attempts < max_attempts:
    try:
        guess = int(input("あなたの予測:"))

        attempts += 1

        if guess == correct_number:
            print(f"おめでとうございます！正解です {attempts} 回目で当てました")
            is_correct = True
            break
        elif guess < correct_number:
            print("もっと大きい数字です。")

        else:
            print("もっと小さい数字です")

        remaining_attempts = max_attempts - attempts
        print(f"残りのチャンスは {remaining_attempts} 回です。")
    
    except ValueError:
        print("無効な入力です。数字を入力してください")
if not is_correct:
    print(f"残念!正解は {correct_number} でした。次回はもっと頑張りましょう")

```

### **実行結果** 
   - 実行結果の記述、**正常に動作した証跡**を明記する
   - テキストはテキストで記述し、
   - 動作確認の様子は、テキスト出力とスクリーンキャプチャを添付する
  

```
PS C:\Users\uyu06\OneDrive\Desktop\PROG-Ⅱ> python number.py
1から100までの数字を当ててください
あなたには 10 回のチャンスがあります。
あなたの予測:50
もっと小さい数字です
残りのチャンスは 9 回です。
あなたの予測:25
もっと大きい数字です。
残りのチャンスは 8 回です。
あなたの予測:35
もっと大きい数字です。
残りのチャンスは 7 回です。
あなたの予測:40
もっと小さい数字です
残りのチャンスは 6 回です。
あなたの予測:38
もっと小さい数字です
残りのチャンスは 5 回です。
あなたの予測:34
もっと大きい数字です。
残りのチャンスは 4 回です。
あなたの予測:36
もっと大きい数字です。
残りのチャンスは 3 回です。
あなたの予測:37
おめでとうございます！正解です 8 回目で当てました
PS C:\Users\uyu06\OneDrive\Desktop\PROG-Ⅱ>
```

----
### **使った技法の説明**

- どこに、どんな概念・技法をなぜ・どのように適用したのか、**自分の言葉で簡潔にまとめる**

- [x]  関数の活用
- [] クロージャの活用
- [x] 例外処理の活用 
- [] プロトコルの活用 
- [] クラスの定義
- [] インヘリタンスの定義
- [] デコレ―タの活用
- [] ジェネレータ、コルーチンの活用
- [] 非同期処理の活用
- [] 非ブロックI/Oの活用
- [] メタクラスの定義、動的クラス生成
- [] デザインパターンの活用
- [] マルチスレッド並列処理
- [] 自作パッケージ作成

　このプログラムでは最初に random.randint(1,100)を使って正解の数字をランダムに決めました。そしてwhileで最大10回まで繰り返して、毎回ユーザーに入力してもらい、正解かどうかを比べる仕組みにしました。
　また、入力は文字が混ざることがあるので、そのままだとエラーで止まってしまうので　try except(ValueError)を入れて、数字じゃない入力が来ても落ちずに数字を入力してと表示して続けられるようにしました。

### *考察** **自己分析**

   - **うまく行かず苦労した点、積み上げた失敗、失敗から学んだ教訓を必ず明記**する
   - 問題解決の考え方・攻略法を自分の言葉で簡潔にまとめる
   - 用いた技法、例えば、関数プログラミングの利点、プロトコルの活用場面について、応用シーンを考察する
   -  やってみて初めて分かったこと
   - 失敗の積み上げで、深く理解したこと
   - **生成AIとの適切な向き合い方**　について考察
   - この課題を通して、まだ改善できると感じた点や他の解法のアイデアを自分の言葉で論じる

　最初は、入力に文字を入れるとプログラムが止まってしまい、なぜ動かなくなるのかわからず苦労しました。また、回数の管理が上手くできず何回目なのかずれてしまう失敗もありました。
　問題解決の考え方はエラーが出たときはいきなり全部を直そうとせず、どの行で止まっているか、どんな入力をしたときに起きるかを1つずつ確認しました。処理の流れをノートに書いたり、頭の中で整理しながら小さな原因を順番に直すことで解決できました。
　コードを見て理解しているつもりでも、実際に動かすと想定していなかった問題が多く出てくることが分かりました。特に入力の扱いは実行して初めて重要さを実感しました。
　失敗を重ねることで、なぜこの書き方が必要なのかを自分の言葉で説明できるようになりました。正しく動いた時よりも、うまくいかなかったときのほうが理解が深まったと感じています。
　今後の改善点として今回のプログラムではすべて一つの流れの中で処理しています。今後は処理を関数に分けたり、クラスとしてまとめることでさらに見やすくできると感じました。また、難易度を選べるようにするなど遊びとしての工夫も追加してみたいです。
------

# フリープログラム

### 作品名：




### **コード全体と、使用した技法の説明** 
   - コードを明記し、**変数・関数・クラスの役割やロジックをコメント等で簡潔に説明**する

```python
import random
from abc import ABC, abstractmethod

class Dice:
    @staticmethod
    def roll():
        return random.randint(1,6)
    
class Monster(ABC):
    def __init__(self, name:str, hp: int = 10):
        self._name = name
        self._hp = hp

    def get_name(self):
        return self._name 
    
    def get_name(self):
        return self._hp
    
    def set_hp(self, value: int):
        if value >= 0:
            self._hp = value
        else:
            print("HPは0以上でなければなりません")

    def dice_roll(self):
        return Dice.roll()
    
    @abstractmethod
    def special_move(self):
        pass

class Slime(Monster):
    def special_move(self):
        return f"{self.get_name()}は体当たりを仕掛けた!"

class Goblin(Monster):
    def special_move(self):
        return f"{self.get_name()}は金棒を振り回した!"
    
class Dragon(Monster):
    def dice_roll(self):
        roll1, roll2 = Dice.roll(), Dice.roll()
        return max(roll1, roll2)
    
    def special_move(self):
        return f"{self.get_name()}は火を吹いた!"
    
class MonsterCaptureGame:
    def __init__(self):
        self.monsters = [Slime("スライム"), Goblin("ゴブリン"), Dragon("ドラゴン")]
        self.captured_monsters = []

    def play(self):
        for monster in self.monsters:
            print(f"{monster.get_name()}が現れた!")
            print(monster.special_move())

            monster_roll = monster.dice_roll()
            print(f"{monster.get_name()}が現れた!")
            print(monster.special_move())

            monster_roll = monster.dice_roll()
            print(f"{monster.get_name()}がサイコロを振った。出目は{monster_roll}")

            response = input("サイコロを振りますか？(yes/no):").strip().lower()
            if response == "no":
                print(f"{monster.get_name()}をスキップしました。")
                continue

            player_roll = Dice.roll()
            print(f"プレイヤーがサイコロを振った。出目は{player_roll}")

            if player_roll > monster_roll:
                print(f"{monster.get_name()}を捕まえた!")
                self.captured_monsters.append(monster.get_name())
            elif player_roll == monster_roll:
                print("引き分けでもう一度!")
                continue
            else:
                print(f"{monster.get_name()}を捕まえられなかった。ゲームオーバー!")
                break
        
        print("捕まえたモンスター:")

```

### **実行結果** 
   - 実行結果の記述、**正常に動作した証跡**を明記する
   - テキストはテキストで記述し、
   - 動作確認の様子は、テキスト出力とスクリーンキャプチャを添付する
  

```
PS C:\Users\uyu06\OneDrive\Desktop\PROG-Ⅱ> python game.py
スライムが現れた！
スライムは体当たりした！
スライムは体当たりした！
スライムがサイコロを振った。出目は 10
サイコロを振りますか？ (yes/no):yes
プレイヤーがサイコロを振った。出目は 3
プレイヤーがサイコロを振った。出目は 3
スライムを捕まえられなかった。ゲームオーバー！
スライムを捕まえられなかった。ゲームオーバー！
捕まえたモンスター:
ゲーム終了
```

----
### **使った技法の説明**

- どこに、どんな概念・技法をなぜ・どのように適用したのか、**自分の言葉で簡潔にまとめる**

- [x]  関数の活用
- [] クロージャの活用
- [x] 例外処理の活用 
- [] プロトコルの活用 
- [x] クラスの定義
- [x] インヘリタンスの定義
- [] デコレ―タの活用
- [] ジェネレータ、コルーチンの活用
- [] 非同期処理の活用
- [] 非ブロックI/Oの活用
- [] メタクラスの定義、動的クラス生成
- [] デザインパターンの活用
- [] マルチスレッド並列処理
- [] 自作パッケージ作成

　このプログラムではモンスター捕獲ゲームを作るためにいくつかのプログラミングの考え方を使いました。
　まず、クラスを使ってサイコロ、モンスター、ゲーム全体をそれぞれ分けて表現しました。
　次に継承を使いMonsterをもとにしてSlime,Goblin,Dragonを作りました。共通する処理は親クラスにまとめ、それぞれのモンスターだけが持つ行動は子クラスででき議することで無駄な重複を減らしました。
　さらにデコレーターを使って、サイコロんおしょりを@staticmethodとして定義しました。

### *考察** **自己分析**
   - ショート・プログラムからの発展性
   - **うまく行かず苦労した点、積み上げた失敗、失敗から学んだ教訓を必ず明記**する
   - 問題解決の考え方・攻略法を自分の言葉で簡潔にまとめる
   - 用いた技法、例えば、関数プログラミングの利点、プロトコルの活用場面について、応用シーンを考察する
   -  やってみて初めて分かったこと
   - 失敗の積み上げで、深く理解したこと
   - **生成AIとの適切な向き合い方**　について考察
   - この課題を通して、まだ改善できると感じた点や他の解法のアイデアを自分の言葉で論じる

　うまくいかず苦労した点、失敗から学んだことはプログラムが動かない原因が分からず、何度もエラーが出て苦労したことです。特にメソッド名の書き間違いや同じ関数を二回定義してしまうミスが多かったです。この失敗からエラーは仕組みが分かってない部分を教えてくれるものであり一つずつ確認することが大切だと学びました。
　問題解決の考え方は問題が起きたときはいきなり全部を直そうとせずに、どの行で止まっているか、その関数は何を返しているかを順番に確認しました。小さな部分ごとに原因を探すことで、混乱せずに修正できるようになりました。
　用いた技法と応用シーンとしてはクラスと継承を使うことで、共通部分と個別の動きを分けて考えられるようになりました。この考え方はゲーム以外でも、共通ルールがあるけど中身が少しずつ違うものを扱う場面で役立つと感じました。
　やってみて初めて分かったことはコードを書いているだけでは分かったつもりでも、実際に動かすと理解が浅い部分がすぐに表れました。特に継承やメソッドの呼ばれ方は、実際に失敗して初めて理解が深まりました。
　失敗の積み上げで深く理解したことは失敗を重ねることで、なぜこの書き方が必要なのかを自分の中で説明できるようになりました。正解を写すだけではなく、間違えた経験が理解につながることを実感しました。
　生成AIはエラーの原因を整理したり、考え方を示してくれる点でとても役に立ちました。一方で、答えをそのまま使うだけでは理解は深まらないと感じました。自分で考えたコードと照らし合わせながら使うことで、学習の助けになると考えます。
　今回のプログラムでは、例外処理や非同期処理などは使っていないので今後は入力ミスへの対応や処理をより安全にする工夫も入れてみたいです。また、設計を工夫することで、さらに見やすく拡張しやすいコードにできると感じました。

----

### 所感・今後の目標課題 (自由記述欄、フィードバック意見を尊重)

- なぜプログラミングを学ぶか
- これまで学んで得た知見
- これからの学びに活かすべき知見
- 適切な生成AIの活用方法についての見解

最初は生成AIに聞かないと何もわからない状態だったけれど少しずつ手を動かしていくことで分からない部分だけヒントを生成AIに聞くだけというところまで成長し、最初はわからなくても手を動かすことが大事だと実感しました。
----